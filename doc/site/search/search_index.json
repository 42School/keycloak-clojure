{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Keycloak Clojure You're here because you want to secure the application you develop. Keycloak is an Identity and Access Management (IAM for short) tool that will handles the identities and their associated permissions that will use your application. Keycloak implements two related open protocols for dealing with authorization and authentication: OAuth 2.0 and OpenID Connect (OIDC) I assume your application is a typical javascript frontend with an API backend (Server-side rendering would not change this assumption that much). The documentation has the following sections: Concepts : Keycloak implements the concepts of the OAuth and OIDC protocols as well as its own concepts. This section explains these concepts and their purpose. Setup : this section exposes an easy way to install Keycloak on your development machine through Docker. Administration : the administration tasks allows to create the different Keycloak resources used later when securing the application Frontend : this section explains how to secure a typical SPA frontend Backend : this section explains how to secure an API backend.","title":"Home"},{"location":"#keycloak-clojure","text":"You're here because you want to secure the application you develop. Keycloak is an Identity and Access Management (IAM for short) tool that will handles the identities and their associated permissions that will use your application. Keycloak implements two related open protocols for dealing with authorization and authentication: OAuth 2.0 and OpenID Connect (OIDC) I assume your application is a typical javascript frontend with an API backend (Server-side rendering would not change this assumption that much). The documentation has the following sections: Concepts : Keycloak implements the concepts of the OAuth and OIDC protocols as well as its own concepts. This section explains these concepts and their purpose. Setup : this section exposes an easy way to install Keycloak on your development machine through Docker. Administration : the administration tasks allows to create the different Keycloak resources used later when securing the application Frontend : this section explains how to secure a typical SPA frontend Backend : this section explains how to secure an API backend.","title":"Keycloak Clojure"},{"location":"admin/","text":"Administrative tasks Administrative tasks Introduction Create a keycloak client Create a realm Create clients Create realm roles Create users Assign roles to user Create groups Declarative creation of Keycloak objects Realm declaration Clients declaration Roles declaration Groups declaration Users declaration Whole data structure for resources declaration Introduction Before using Keycloak you must create the necessary resources in the following order: firstly you create a realm that will holds your clients, roles, groups and then users (See the Keycloak concepts section ). You can create all theses resources through the Keycloak administration console or keycloak-clojure brings you functions to do that easily that are detailed in the next sections. Create a keycloak client In every interaction with keycloak-clojure you must provide a keycloak client object that holds the server reference, password, etc. The keycloak client is created with: (require '[keycloak.deployment :as deployment :refer [keycloak-client client-conf]]) (def kc-client (-> (client-conf {:auth-server-url \"http://localhost:8090/auth\" :realm \"master\" :client-id \"admin-cli\"}) (keycloak-client \"admin\" \"secretadmin\"))) Create a realm (require '[keycloak.admin :as admin]) (admin/create-realm! kc-client \"example-realm\") Create clients (admin/create-client! kc-client \"example-realm\" \"myfrontend\") (admin/create-client! kc-client \"example-realm\" \"mybackend\") Create realm roles (admin/create-role! kc-client \"example-realm\" \"employee\") (admin/create-role! kc-client \"example-realm\" \"manager\") Create users (admin/create-user! kc-client \"example-realm\" \"user1\" \"pwd1\") ;; The keycloak.user namespace contains function with more exhaustive parameters like: (require '[keycloak.user :as user]) (user/create-or-update-user! kc-client \"example-realm\" {:username \"bcarter\" :first-name \"Bob\" :last-name \"Carter\" :password \"abcdefg\" :email \"bcarter@example.com\"} [\"employee\" \"manager\"] nil) Assign roles to user (require '[keycloak.user :as user]) (user/add-realm-roles! kc-client \"example-realm\" \"bcarter\" [\"manager\"]) Create groups (admin/create-group! kc-client \"example-realm\" \"mygroup\") (admin/add-username-to-group-name! kc-client \"example-realm\" \"mygroup\" \"bcarter\") Declarative creation of Keycloak objects Keycloak-clojure offers a declarative way to create all the Keycloak resources instead of invoking all the imperative functions. The init! function to create all the resource sits in the namespace keycloak.starter . The function expects the following top-level keys: :realm , :clients , :roles , :groups , :users . Two additional keys provides a way to generate fake users, groups and roles: :generated-users-by-group-and-role and :username-creator-fn . Realm declaration {:name \"electre\" :themes {:internationalizationEnabled true :supportedLocales #{\"en\" \"fr\"} :defaultLocale \"fr\" :loginTheme \"example-theme\" :accountTheme \"example-theme\" :adminTheme nil :emailTheme \"example-theme\"} :login {:bruteForceProtected true :rememberMe true :resetPasswordAllowed true} :tokens {:ssoSessionIdleTimeoutRememberMe (Integer. (* 60 60 48)) ;2 days :ssoSessionMaxLifespanRememberMe (Integer. (* 60 60 48))} :smtp {:host \"smtp.eu.mailgun.org\" :port 587 :from \"admin@example.com\" :auth true :starttls true :replyTo \"example\" :user \"postmaster@mail.example.com\" :password \"\"}} Clients declaration {:clients [{:name \"api-client\" :public? true :redirect-uris [\"https://api.example.com/*\"] :root-url \"https://api.example.com\" :base-url \"https://api.example.com\" :web-origins [\"https://api.example.com\"]} {:name \"myfrontend\" :public? true :redirect-uris [\"https://www.example.com/*\"] :root-url \"https://www.example.com\" :base-url \"https://www.example.com\" :web-origins [\"https://www.example.com\"]} {:name \"mybackend\" :public? false :redirect-uris [\"http://localhost:3449/*\"] :web-origins [\"http://localhost:3449\"]}]} Roles declaration {:roles #{\"employee\" \"manager\" \"admin\" \"org-admin\" \"group-admin\" \"api-consumer\"}} Groups declaration {:groups [{:name \"group1\" :subgroups [\"subgroup1\" \"subgroup2\"]}]} Users declaration {:users [{:username \"bcarter\" :password \"password\" :first-name \"Bob\" :last-name \"Carter\" :realm-roles [\"employee\" \"manager\"] :group \"group1\" :in-subgroups [\"subgroup2\"] :attributes {\"myorg\" [\"ACME\"]}}]} Whole data structure for resources declaration (require '[keycloak.starter :as starter]) (starter/init! {:realm ... :clients ... :roles ... :groups ... :users ... :generated-users-by-group-and-role 3 :username-creator-fn (fn [role group subgroup i & opts] (str (str group) \"-\" (subs (str role) 0 3) \"-\" i))})","title":"Keycloak Administration"},{"location":"admin/#administrative-tasks","text":"Administrative tasks Introduction Create a keycloak client Create a realm Create clients Create realm roles Create users Assign roles to user Create groups Declarative creation of Keycloak objects Realm declaration Clients declaration Roles declaration Groups declaration Users declaration Whole data structure for resources declaration","title":"Administrative tasks"},{"location":"admin/#introduction","text":"Before using Keycloak you must create the necessary resources in the following order: firstly you create a realm that will holds your clients, roles, groups and then users (See the Keycloak concepts section ). You can create all theses resources through the Keycloak administration console or keycloak-clojure brings you functions to do that easily that are detailed in the next sections.","title":"Introduction"},{"location":"admin/#create-a-keycloak-client","text":"In every interaction with keycloak-clojure you must provide a keycloak client object that holds the server reference, password, etc. The keycloak client is created with: (require '[keycloak.deployment :as deployment :refer [keycloak-client client-conf]]) (def kc-client (-> (client-conf {:auth-server-url \"http://localhost:8090/auth\" :realm \"master\" :client-id \"admin-cli\"}) (keycloak-client \"admin\" \"secretadmin\")))","title":"Create a keycloak client"},{"location":"admin/#create-a-realm","text":"(require '[keycloak.admin :as admin]) (admin/create-realm! kc-client \"example-realm\")","title":"Create a realm"},{"location":"admin/#create-clients","text":"(admin/create-client! kc-client \"example-realm\" \"myfrontend\") (admin/create-client! kc-client \"example-realm\" \"mybackend\")","title":"Create clients"},{"location":"admin/#create-realm-roles","text":"(admin/create-role! kc-client \"example-realm\" \"employee\") (admin/create-role! kc-client \"example-realm\" \"manager\")","title":"Create realm roles"},{"location":"admin/#create-users","text":"(admin/create-user! kc-client \"example-realm\" \"user1\" \"pwd1\") ;; The keycloak.user namespace contains function with more exhaustive parameters like: (require '[keycloak.user :as user]) (user/create-or-update-user! kc-client \"example-realm\" {:username \"bcarter\" :first-name \"Bob\" :last-name \"Carter\" :password \"abcdefg\" :email \"bcarter@example.com\"} [\"employee\" \"manager\"] nil)","title":"Create users"},{"location":"admin/#assign-roles-to-user","text":"(require '[keycloak.user :as user]) (user/add-realm-roles! kc-client \"example-realm\" \"bcarter\" [\"manager\"])","title":"Assign roles to user"},{"location":"admin/#create-groups","text":"(admin/create-group! kc-client \"example-realm\" \"mygroup\") (admin/add-username-to-group-name! kc-client \"example-realm\" \"mygroup\" \"bcarter\")","title":"Create groups"},{"location":"admin/#declarative-creation-of-keycloak-objects","text":"Keycloak-clojure offers a declarative way to create all the Keycloak resources instead of invoking all the imperative functions. The init! function to create all the resource sits in the namespace keycloak.starter . The function expects the following top-level keys: :realm , :clients , :roles , :groups , :users . Two additional keys provides a way to generate fake users, groups and roles: :generated-users-by-group-and-role and :username-creator-fn .","title":"Declarative creation of Keycloak objects"},{"location":"admin/#realm-declaration","text":"{:name \"electre\" :themes {:internationalizationEnabled true :supportedLocales #{\"en\" \"fr\"} :defaultLocale \"fr\" :loginTheme \"example-theme\" :accountTheme \"example-theme\" :adminTheme nil :emailTheme \"example-theme\"} :login {:bruteForceProtected true :rememberMe true :resetPasswordAllowed true} :tokens {:ssoSessionIdleTimeoutRememberMe (Integer. (* 60 60 48)) ;2 days :ssoSessionMaxLifespanRememberMe (Integer. (* 60 60 48))} :smtp {:host \"smtp.eu.mailgun.org\" :port 587 :from \"admin@example.com\" :auth true :starttls true :replyTo \"example\" :user \"postmaster@mail.example.com\" :password \"\"}}","title":"Realm declaration"},{"location":"admin/#clients-declaration","text":"{:clients [{:name \"api-client\" :public? true :redirect-uris [\"https://api.example.com/*\"] :root-url \"https://api.example.com\" :base-url \"https://api.example.com\" :web-origins [\"https://api.example.com\"]} {:name \"myfrontend\" :public? true :redirect-uris [\"https://www.example.com/*\"] :root-url \"https://www.example.com\" :base-url \"https://www.example.com\" :web-origins [\"https://www.example.com\"]} {:name \"mybackend\" :public? false :redirect-uris [\"http://localhost:3449/*\"] :web-origins [\"http://localhost:3449\"]}]}","title":"Clients declaration"},{"location":"admin/#roles-declaration","text":"{:roles #{\"employee\" \"manager\" \"admin\" \"org-admin\" \"group-admin\" \"api-consumer\"}}","title":"Roles declaration"},{"location":"admin/#groups-declaration","text":"{:groups [{:name \"group1\" :subgroups [\"subgroup1\" \"subgroup2\"]}]}","title":"Groups declaration"},{"location":"admin/#users-declaration","text":"{:users [{:username \"bcarter\" :password \"password\" :first-name \"Bob\" :last-name \"Carter\" :realm-roles [\"employee\" \"manager\"] :group \"group1\" :in-subgroups [\"subgroup2\"] :attributes {\"myorg\" [\"ACME\"]}}]}","title":"Users declaration"},{"location":"admin/#whole-data-structure-for-resources-declaration","text":"(require '[keycloak.starter :as starter]) (starter/init! {:realm ... :clients ... :roles ... :groups ... :users ... :generated-users-by-group-and-role 3 :username-creator-fn (fn [role group subgroup i & opts] (str (str group) \"-\" (subs (str role) 0 3) \"-\" i))})","title":"Whole data structure for resources declaration"},{"location":"backend/","text":"Securing a backend Securing a backend Yada Buddy-Auth Yada Buddy-Auth","title":"Securing Backend"},{"location":"backend/#securing-a-backend","text":"Securing a backend Yada Buddy-Auth","title":"Securing a backend"},{"location":"backend/#yada","text":"","title":"Yada"},{"location":"backend/#buddy-auth","text":"","title":"Buddy-Auth"},{"location":"concepts/","text":"Security Concepts Security Concepts Generic OAuth2 / OpenId Connect (OIDC) concepts Differences between OAuth2 and OIDC Keycloak concepts Generic Identification and Authentication Identification means knowing who is interacting with your application and so you need a repository of identities (the persons or systems that interact with your application). Those identities can be handled by keycloak itself or it can delegates to Authorization Confidentiality and integrity OAuth2 / OpenId Connect (OIDC) concepts Below are the OAuth2/OIDC concepts, with the specificities of an application composed of an SPA frontend and an API backend. Resource : the thing you want to protect. your API if you develop a backend for instance Resource Owner : the owner of the identity, data and any actions that can be performed with the identity. if you develop an API, you'll typically include then extract the roles from the access token the backend will receive Client : The application that wants to access data or perform actions on behalf of the Resource Owner. If you develop an application with an SPA as frontend and backend with an API, both your frontend and backend will be client Authorization Server : The system that knows the Resource Owner. Here we're talking about Keycloak. Resource Server : The Application Programming Interface (API) or service the Client wants to use on behalf of the Resource Owner. The backend of your application OpenID provider (OP) : The OpenID provider is an OAuth 2.0 authorization server which offers authentication as a service. It ensures the end user is authenticated and provides claims about the end user and the authentication event to the relying party. The identity provider provides the relying party information about the end user through identity tokens. Different types of tokens are exchanged between the participants to verify the identity or provide access permissions. Tokens. Establishes a user\u2019s identity during a transaction. These common token types are supported: Access token . Gives permission to the client application to obtain end-user owned resources from a resource server. It is an opaque token that is validated by fetching user claims from userInfo endpoint. Redirect URI : The URL the Authorization Server will redirect the Resource Owner back to after granting permission to the Client. This is sometimes referred to as the \u201cCallback URL\u201d. Once you have some permissions given by Keycloak as an Access Token (see below), Keycloak will redirect towards your frontend, so it's the URL where your frontend sits Response Type : The type of information the Client expects to receive. The most common Response Type is code, where the Client expects an Authorization Code. Scope : These are the granular permissions the Client wants, such as access to data or to perform actions. Consent : The Authorization Server takes the Scopes the Client is requesting, and verifies with the Resource Owner whether or not they want to give the Client permission. Client ID : This ID is used to identify the Client with the Authorization Server. When you ask for an access token, you'll give the client-id on behalf of which you ask permissions, say you have api client, you can create a specific client in Keycloak for that particular use case Client Secret : This is a secret password that only the Client and Authorization Server know. This allows them to securely share information privately behind the scenes. This is typically for your backend that you materialize as a client. Keycloak expects your backend to be able to holds some confidentiality, therefore holding a secret to prove its identity with Keycloak. Authorization Code : A short-lived temporary code the Client gives the Authorization Server in exchange for an Access Token. Access Token : The key the client will use to communicate with the Resource Server. This is like a badge or key card that gives the Client permission to request data or perform actions with the Resource Server on your behalf. this is the data that will be exchanged between your frontend and your ID Token : Similar to a ID card or passport, it contains many required attributes or claims about the user. Differences between OAuth2 and OIDC Keycloak concepts Keycloak comes with many concepts closely related to the OAuth ones: Realm is the core concept in Keycloak. A realm secures and manages security metadata for a set of users, applications and registered oauth clients. A client is a service, i.e. a runtime component talking to keycloak, that is secured by a realm . Once your realm is created, you can create a client : e.g. web frontend code in a browser, mobile frontend code in a React Native app, API server, etc. You will often use Client for every Application secured by Keycloak. When a user browses an application's web site, the application can redirect the user agent to the Keycloak Server and request a login. Once a user is logged in, they can visit any other client (application) managed by the realm and not have to re-enter credentials. This also hold true for logging out. Roles can also be defined at the client level and assigned to specific users. Depending on the client type, you may also be able to view and manage user sessions from the administration console. Adapters are keycloak librairies in different technologies used for client to communicate with the keycloak servers. Luckily thanks to Clojure and Clojurescript running on hosted platform, respectively the JVM and the JS engine, we can use the Keycloak Java Adapter and the Keycloak Jsvascript Adapter . OpenId Connect terminology is implemented by keycloak.","title":"Concepts"},{"location":"concepts/#security-concepts","text":"Security Concepts Generic OAuth2 / OpenId Connect (OIDC) concepts Differences between OAuth2 and OIDC Keycloak concepts","title":"Security Concepts"},{"location":"concepts/#generic","text":"Identification and Authentication Identification means knowing who is interacting with your application and so you need a repository of identities (the persons or systems that interact with your application). Those identities can be handled by keycloak itself or it can delegates to Authorization Confidentiality and integrity","title":"Generic"},{"location":"concepts/#oauth2-openid-connect-oidc-concepts","text":"Below are the OAuth2/OIDC concepts, with the specificities of an application composed of an SPA frontend and an API backend. Resource : the thing you want to protect. your API if you develop a backend for instance Resource Owner : the owner of the identity, data and any actions that can be performed with the identity. if you develop an API, you'll typically include then extract the roles from the access token the backend will receive Client : The application that wants to access data or perform actions on behalf of the Resource Owner. If you develop an application with an SPA as frontend and backend with an API, both your frontend and backend will be client Authorization Server : The system that knows the Resource Owner. Here we're talking about Keycloak. Resource Server : The Application Programming Interface (API) or service the Client wants to use on behalf of the Resource Owner. The backend of your application OpenID provider (OP) : The OpenID provider is an OAuth 2.0 authorization server which offers authentication as a service. It ensures the end user is authenticated and provides claims about the end user and the authentication event to the relying party. The identity provider provides the relying party information about the end user through identity tokens. Different types of tokens are exchanged between the participants to verify the identity or provide access permissions. Tokens. Establishes a user\u2019s identity during a transaction. These common token types are supported: Access token . Gives permission to the client application to obtain end-user owned resources from a resource server. It is an opaque token that is validated by fetching user claims from userInfo endpoint. Redirect URI : The URL the Authorization Server will redirect the Resource Owner back to after granting permission to the Client. This is sometimes referred to as the \u201cCallback URL\u201d. Once you have some permissions given by Keycloak as an Access Token (see below), Keycloak will redirect towards your frontend, so it's the URL where your frontend sits Response Type : The type of information the Client expects to receive. The most common Response Type is code, where the Client expects an Authorization Code. Scope : These are the granular permissions the Client wants, such as access to data or to perform actions. Consent : The Authorization Server takes the Scopes the Client is requesting, and verifies with the Resource Owner whether or not they want to give the Client permission. Client ID : This ID is used to identify the Client with the Authorization Server. When you ask for an access token, you'll give the client-id on behalf of which you ask permissions, say you have api client, you can create a specific client in Keycloak for that particular use case Client Secret : This is a secret password that only the Client and Authorization Server know. This allows them to securely share information privately behind the scenes. This is typically for your backend that you materialize as a client. Keycloak expects your backend to be able to holds some confidentiality, therefore holding a secret to prove its identity with Keycloak. Authorization Code : A short-lived temporary code the Client gives the Authorization Server in exchange for an Access Token. Access Token : The key the client will use to communicate with the Resource Server. This is like a badge or key card that gives the Client permission to request data or perform actions with the Resource Server on your behalf. this is the data that will be exchanged between your frontend and your ID Token : Similar to a ID card or passport, it contains many required attributes or claims about the user.","title":"OAuth2 / OpenId Connect (OIDC) concepts"},{"location":"concepts/#differences-between-oauth2-and-oidc","text":"","title":"Differences between OAuth2 and OIDC"},{"location":"concepts/#keycloak-concepts","text":"Keycloak comes with many concepts closely related to the OAuth ones: Realm is the core concept in Keycloak. A realm secures and manages security metadata for a set of users, applications and registered oauth clients. A client is a service, i.e. a runtime component talking to keycloak, that is secured by a realm . Once your realm is created, you can create a client : e.g. web frontend code in a browser, mobile frontend code in a React Native app, API server, etc. You will often use Client for every Application secured by Keycloak. When a user browses an application's web site, the application can redirect the user agent to the Keycloak Server and request a login. Once a user is logged in, they can visit any other client (application) managed by the realm and not have to re-enter credentials. This also hold true for logging out. Roles can also be defined at the client level and assigned to specific users. Depending on the client type, you may also be able to view and manage user sessions from the administration console. Adapters are keycloak librairies in different technologies used for client to communicate with the keycloak servers. Luckily thanks to Clojure and Clojurescript running on hosted platform, respectively the JVM and the JS engine, we can use the Keycloak Java Adapter and the Keycloak Jsvascript Adapter . OpenId Connect terminology is implemented by keycloak.","title":"Keycloak concepts"},{"location":"frontend/","text":"Securing a frontend","title":"Securing Frontend"},{"location":"frontend/#securing-a-frontend","text":"","title":"Securing a frontend"},{"location":"setup/","text":"Setup Keycloak Keycloak comes vith various way of running it : Bare server, Docker, Kubernetes, OpenShift, etc.. Keycloak server installation and configuration documentation is excellent. Keycloak needs a database to run and offers several choices (Oracle, SQL Server, PostgreSQL, MySQL), by default it uses an H2 embedded database. I choose to run Keycloak with Postgres as it's easier to investigate data in a Postgres DB and it's now very frequent that I choose Postgres for my persistence needs. Docker-compose with Postgres During development, I choose Docker Compose to run Postgres alongside Keycloak, the repository holds a docker-compose.yml file to easily starts a Keycloak standalone instance persisting data in a Postgres DB. To start Keycloak with Postgres: install Docker Compose Clone this repo: git clone git@github.com:jgrodziski/keycloak-clojure.git and execute: docker-compose up (by the way go check that gist of useful docker aliases ) you should now have two running containers: Keycloak and Postgres (check with docker ps ) the Keycloak administration console is now available at http://localhost:8090","title":"Setup"},{"location":"setup/#setup-keycloak","text":"Keycloak comes vith various way of running it : Bare server, Docker, Kubernetes, OpenShift, etc.. Keycloak server installation and configuration documentation is excellent. Keycloak needs a database to run and offers several choices (Oracle, SQL Server, PostgreSQL, MySQL), by default it uses an H2 embedded database. I choose to run Keycloak with Postgres as it's easier to investigate data in a Postgres DB and it's now very frequent that I choose Postgres for my persistence needs.","title":"Setup Keycloak"},{"location":"setup/#docker-compose-with-postgres","text":"During development, I choose Docker Compose to run Postgres alongside Keycloak, the repository holds a docker-compose.yml file to easily starts a Keycloak standalone instance persisting data in a Postgres DB. To start Keycloak with Postgres: install Docker Compose Clone this repo: git clone git@github.com:jgrodziski/keycloak-clojure.git and execute: docker-compose up (by the way go check that gist of useful docker aliases ) you should now have two running containers: Keycloak and Postgres (check with docker ps ) the Keycloak administration console is now available at http://localhost:8090","title":"Docker-compose with Postgres"}]}